{"meta":{"title":"测试开发技术分享","subtitle":"走在春风里，满天的繁星追赶着我。","description":"测试开发工程师","author":"iread9527","url":"http://yoursite.com","root":"/"},"pages":[{"title":"文章分类汇总","date":"2019-08-03T02:06:30.000Z","updated":"2019-08-03T02:54:34.131Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-03T02:30:58.000Z","updated":"2019-08-03T02:31:35.670Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"pytest配置文件","slug":"pytestini","date":"2019-08-01T14:50:54.000Z","updated":"2019-08-05T13:10:30.571Z","comments":true,"path":"2019/08/01/pytestini/","link":"","permalink":"http://yoursite.com/2019/08/01/pytestini/","excerpt":"","text":"pytest配置文件pytest.ini12345678[pytest]addopts = --strict-markersmarkers = p0: test case tag p0 p1: test case tag p1 global_internal: global test","categories":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/categories/接口测试框架/"}],"tags":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/tags/接口测试框架/"}]},{"title":"pytest测试框架","slug":"pytest测试框架","date":"2019-08-01T14:48:31.000Z","updated":"2019-08-03T03:36:33.640Z","comments":true,"path":"2019/08/01/pytest测试框架/","link":"","permalink":"http://yoursite.com/2019/08/01/pytest测试框架/","excerpt":"0、 安装0.0、 pip install -U pytest0.1、编写pytest测试用例，只需要按照下面的规则： 测试文件以test_开头（以_test结尾也可以） 测试类以Test开头，并且不能带有 init 方法 测试函数以test_开头 断言使用基本的assert即可","text":"0、 安装0.0、 pip install -U pytest0.1、编写pytest测试用例，只需要按照下面的规则： 测试文件以test_开头（以_test结尾也可以） 测试类以Test开头，并且不能带有 init 方法 测试函数以test_开头 断言使用基本的assert即可 1、执行一个文件下的所有测试文件1pytest testing/ 2、给用例打标签并且只执行相应标签的用例2.0、在pytest.ini注册标签，strict-markers表示使用没注册标签的用例都会报错，p0为标签，冒号后面是标签的注释，可选1234567# content of pytest.ini[pytest]addopts = --strict-markers markers = p0: test case tag p0 p1: test case tag p1 testid: test case id 2.1、测试用例1234567891011# content of test_mark.pyimport pytest @pytest.mark.p0@pytest.mark.testiddef test_1(): assert abs(-1) == 1@pytest.mark.p1def test_2(): assert abs(-1) == -1 2.2、执行打了特定标签的用例们123pytest -m p0pytest -m \"not p0\"pytest -m \"p0 or p1\" 3、pytst的fixture3.0、pytest前置和后置用例conftest.py12345678910111213141516# content of conftest.pyimport pytest# scope范围为session,module,class,function,范围前后各执行一次@pytest.fixture(scope=\"module\")def module_fixture(): print('module start') yield 1 print('module stop')@pytest.fixture(scope=\"function\")def function_fixture(): print('function start') yield 1 print('function stop') 3.1、pytest测试用例，可用pytest -s test_fuction.py查看结果123456789# content of test_function.pydef test_1(module_fixture, function_fixture): assert module_fixture == 1 assert function_fixture == 1def test_2(module_fixture, function_fixture): assert module_fixture == 1 assert function_fixture == 1 3.2、pytest fixture具体执行过程1234567891011121314151. 先找到所有 test_开头的文件2. 在测试脚本文件同一级目录下寻找conftest.py3. 按随机顺序执行测试脚本文件中的测试方法4. 执行第一个测试方法，发现有一个传入参数 module_fixture，在测试配置文件中寻找名为 module_fixture 的fixture5. 执行测试配置文件中的 module_fixture 方法，保存返回值6. 把上一步的返回值代入第4步的测试方法传入参数中，执行第一个测试方法7. 执行第二个测试方法，发现有一个传入参数 module_fixture ，在测试配置文件中寻找名为 module_fixture 的fixture8. 发现这个fixture的范围是module，无需重复执行，使用第5步的返回值继续执行第7步的第二个测试方法 4、pytest 重新执行失败用例1pytest --lf 5、pytest执行打印控制台日志，并设置日志级别123[pytest]log_cli=true log_level=NOTSET 6、生成测试报告1234# 生成xml格式测试报告pytest testing/ --junit-xml=report.xml# 插件pytest-html生成测试报告并保留网页格式pytest testing/ --html=report.html --self-contained-html 7、Console参数介绍 -v 用于显示每个测试函数的执行结果 -q 只显示整体测试结果 -s 用于显示测试函数中print()函数输出","categories":[{"name":"pytest","slug":"pytest","permalink":"http://yoursite.com/categories/pytest/"}],"tags":[{"name":"pytest","slug":"pytest","permalink":"http://yoursite.com/tags/pytest/"}]},{"title":"run_tests","slug":"run-tests","date":"2019-07-31T13:56:07.000Z","updated":"2019-08-03T03:49:01.059Z","comments":true,"path":"2019/07/31/run-tests/","link":"","permalink":"http://yoursite.com/2019/07/31/run-tests/","excerpt":"interface/run_tests.py","text":"interface/run_tests.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import timeimport osimport smtplibfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.header import Headerfrom email.utils import parseaddr, formataddrfrom os.path import abspathfrom os.path import dirnamedef _format_addr(s): # 格式化地址 name, address = parseaddr(s) return formataddr((Header(name, \"utf-8\").encode(), address))def send_email(file_path): mail_host = \"smtp.163.com\" sender = '18717303689@163.com' password = \"yw455625806a\" receivers = ['2652929865@qq.com', '18717303689@163.com'] file_name = file_path.split('/')[-1] print(file_name) with open(file_path, 'rb') as f: mail_body = f.read() # 创建一个带附件的实例 message = MIMEMultipart() message['From'] = _format_addr('emai发送者&lt;&#123;&#125;&gt;'.format(sender)) for receiver in receivers: message['To'] = _format_addr('emai接收者&lt;&#123;&#125;&gt;,'.format(receiver)) subject = '接口测试测试报告' message['Subject'] = Header(subject, 'utf-8') # 邮件正文内容 content = MIMEText('测试报告已发送，请查收，详情见附件。', 'plain', 'utf-8') message.attach(content) # 构造附件 att1 = MIMEText(mail_body, 'base64', 'utf-8') att1[\"Content-Type\"] = 'application/octet-stream' # 写什么名字，邮件中显示什么名字 att1[\"Content-Disposition\"] = 'attachment; filename=&#123;&#125;'.format(file_name) message.attach(att1) try: server = smtplib.SMTP(mail_host) server.login(sender, password) server.sendmail(sender, receivers, message.as_string()) server.quit() print(\"邮件发送成功\") except smtplib.SMTPException as e: print(\"Error: 无法发送邮件\", e)if __name__ == \"__main__\": now = time.strftime(\"%Y-%m-%d_%H:%M:%S\") root_file_path = dirname(abspath(__file__)) report_file_path = root_file_path + '/report/' + now + '_result.html' test_case_file_path = root_file_path + '/testcases/' pytest_file_path = root_file_path + '/venv/bin/pytest' command = pytest_file_path + ' -q ' + test_case_file_path + \\ ' --html=' + report_file_path + ' --self-contained-html' print('pytest command line: ' + command) os.system(command) send_email(report_file_path)","categories":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/categories/接口测试框架/"}],"tags":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/tags/接口测试框架/"}]},{"title":"readme","slug":"readme","date":"2019-07-31T13:55:19.000Z","updated":"2019-08-03T03:36:45.344Z","comments":true,"path":"2019/07/31/readme/","link":"","permalink":"http://yoursite.com/2019/07/31/readme/","excerpt":"测试报告：pytest-html测试执行器：pytest测试驱动库：requests测试数据管理：接口数据放在urls目录下的枚举类，测试接口所需数据直接写在用例里面代码风格：使用autopep8格式化代码","text":"测试报告：pytest-html测试执行器：pytest测试驱动库：requests测试数据管理：接口数据放在urls目录下的枚举类，测试接口所需数据直接写在用例里面代码风格：使用autopep8格式化代码 1 common模块：1.1 DataProcess: body体中随便命名的加时间戳，响应结果的异常场景处理1.2 my_logger:打印日志，可以根据日志大小和时间来切割日志1.3 RestClient：通用http请求基础类，把各种http请求还有常用的日志打印封装起来2 module模块：2.1 业务层接口的封装，主要的功能是对响应结果的解析取得相应的字段2.2 业务层接口封装类原则：每个应该有唯一的id(文件名类名方法名),编写人，创建时间，修改时间(进一步考虑)3 testcases：测试用例3.1 最多需要输入四个参数：url,headers,params,data或者json3.2 测试用例：3.2.1 每个测试用例都需要分级别并且打标签；###### 3.2.2 测试用例结果应该校验；3.2.3 需要支持并发执行；(未完成)3.2.4 用例之间的依赖关系;3.2.5 应该有前置用例4 run_tests：4.1 支持生成定制的测试报告和发送邮件(用例数，测试报告正确的错误的汇总的，用例id出错在哪,具体错误的日志，总的执行时间)4.2 jekins配置定时任务4.3 执行结果有总时间限制（15分钟内完成）5 用例自身解耦（删除资源，name唯一），用例和用例之间解耦（并发），用例和环境还有人员解耦","categories":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/categories/接口测试框架/"}],"tags":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/tags/接口测试框架/"}]},{"title":"urls","slug":"urls","date":"2019-07-31T13:50:16.000Z","updated":"2019-08-03T03:48:03.068Z","comments":true,"path":"2019/07/31/urls/","link":"","permalink":"http://yoursite.com/2019/07/31/urls/","excerpt":"urls/ManagerURL.py123456789# -*-coding:utf-8-*-from enum import Enum, unique@uniqueclass ManagerURL(Enum): \"\"\"Manager服务接口\"\"\" add_event = '/add_event' get_event_list = '/get_event_list'","text":"urls/ManagerURL.py123456789# -*-coding:utf-8-*-from enum import Enum, unique@uniqueclass ManagerURL(Enum): \"\"\"Manager服务接口\"\"\" add_event = '/add_event' get_event_list = '/get_event_list' urls/RootURL.py123456from enum import Enum, unique@uniqueclass RootURL(Enum): beta_global = 'http://127.0.0.1:8000/api'","categories":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/categories/接口测试框架/"}],"tags":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/tags/接口测试框架/"}]},{"title":"conftest","slug":"conftest","date":"2019-07-31T13:48:48.000Z","updated":"2019-08-03T03:50:35.114Z","comments":true,"path":"2019/07/31/conftest/","link":"","permalink":"http://yoursite.com/2019/07/31/conftest/","excerpt":"testcases/conftest.py","text":"testcases/conftest.py 123456789101112131415161718192021import pytestfrom urls.root_url import RootURLfrom common.DataProcess import DataProcessfrom module.iammanager.ManagerDomain import ManagerDomain@pytest.fixture(scope='module')def manager_domain(): domain = ManagerDomain() return domain@pytest.fixture(scope='module')def data_helper(): data_process = DataProcess() return data_process@pytest.fixture(scope='module')def root_url(): return RootURL.beta_global.value","categories":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/categories/接口测试框架/"}],"tags":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/tags/接口测试框架/"}]},{"title":"test_add_event","slug":"test-add-event","date":"2019-07-31T13:47:03.000Z","updated":"2019-08-05T13:09:04.761Z","comments":true,"path":"2019/07/31/test-add-event/","link":"","permalink":"http://yoursite.com/2019/07/31/test-add-event/","excerpt":"testcases/ManagerDomain/test_add_event.py","text":"testcases/ManagerDomain/test_add_event.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import pytestfrom urls.RootURL import RootURLfrom common.DataProcess import DataProcessfrom module.iammanager.ManagerDomain import ManagerDomain@pytest.mark.p0@pytest.mark.global_internaldef test_add_del_update_get_event(): event_interface = EventInterface() event_interface.add_event() event_interface.get_event()class EventInterface(object): def __init__(self): self.manager_domain = ManagerDomain() self.data_helper = DataProcess() self.root_url = RootURL.beta_global.value self.event_name = None def add_event(self): \"\"\"添加发布会用例\"\"\" # 构建headers headers = &#123;'Authorization': 'Basic YWRtaW46YWRtaW4xMjM0NTY='&#125; # 构建body体 time_now = self.data_helper.time_stamp() name = self.data_helper.param_time_stamp('发布会') body = &#123;'eid': time_now, 'name': name, 'limit': 2000, 'address': \"深圳宝体\", 'start_time': '2017-05-10 12:00:00'&#125; # 发送请求 result = self.manager_domain.add_event( root_url=self.root_url, headers=headers, body=body) # 返回结果设置断言 assert result['status'] == 200 assert result['message'] == 'add event success' # 输出相应的字段 self.event_name = name def get_event(self): \"\"\"获取发布会列表用例\"\"\" # 构建headers headers = &#123;'Authorization': 'Basic YWRtaW46YWRtaW4xMjM0NTY='&#125; # 构建查询参数 query_params = &#123;'name': self.event_name&#125; # 发送请求 result = self.manager_domain.get_event_list( root_url=self.root_url, headers=headers, params=query_params) # 返回结果设置断言 assert result['status'] == 200 assert result['message'] == 'success'","categories":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/categories/接口测试框架/"}],"tags":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/tags/接口测试框架/"}]},{"title":"ManagerDomain","slug":"ManagerDomain","date":"2019-07-31T13:43:45.000Z","updated":"2019-08-05T13:08:09.720Z","comments":true,"path":"2019/07/31/ManagerDomain/","link":"","permalink":"http://yoursite.com/2019/07/31/ManagerDomain/","excerpt":"module/iammanager/ManagerDomain.py","text":"module/iammanager/ManagerDomain.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from urls.RootURL import RootURLfrom urls.ManagerURL import ManagerURLfrom common.RestClient import RestClientfrom common.DataProcess import DataProcessclass ManagerDomain(RestClient): \"\"\"接口调用的封装，主要专注处理返回结果的字段处理\"\"\" def add_event(self, root_url, headers, body): \"\"\" 添加发布会 POST /add_event 接口文档地址 \"\"\" log_description = 'module-iammanager-ManagerDomain-add_event ' url = root_url + ManagerURL.add_event.value result = self.request(method='post', url=url, headers=headers, data=body, log_description=log_description) if result['status'] == 200: result['result_message'] = result['message'] self.logger.info(log_description + 'result: &#123;&#125;'.format(result)) return result def get_event_list(self, root_url, headers, params): \"\"\" 添加发布会 GET /get_event_list&#123;?eid,name&#125; 接口文档地址 \"\"\" log_description = 'module-iammanager-ManagerDomain-get_event_list ' url = root_url + ManagerURL.get_event_list.value result = self.request(method='get', url=url, headers=headers, params=params, log_description=log_description) if result['status'] == 200: result['event_name'] = result['data'][0]['name'] self.logger.info(log_description + 'result: &#123;&#125;'.format(result)) return resultif __name__ == '__main__': test = ManagerDomain() root_url = RootURL.beta_global.value headers = &#123;'Authorization': 'Basic YWRtaW46YWRtaW4xMjM0NTY='&#125; name = &#123;'name': '红米Pro发布会'&#125; result = test.get_event_list(root_url=root_url, headers=headers, params=name) assert result['status'], 200 assert result['message'], 'success' headers = &#123;'Authorization': 'Basic YWRtaW46YWRtaW4xMjM0NTY='&#125; data_helper = DataProcess() time_now = data_helper.time_stamp() name = data_helper.param_time_stamp('发布会') body = &#123;'eid': time_now, 'name': name, 'limit': 2000, 'address': \"深圳宝体\", 'start_time': '2017-05-10 12:00:00'&#125; result = test.add_event( root_url=root_url, headers=headers, body=body)","categories":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/categories/接口测试框架/"}],"tags":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/tags/接口测试框架/"}]},{"title":"dataprocess","slug":"dataprocess","date":"2019-07-29T15:15:42.000Z","updated":"2019-08-03T03:50:16.486Z","comments":true,"path":"2019/07/29/dataprocess/","link":"","permalink":"http://yoursite.com/2019/07/29/dataprocess/","excerpt":"dataprocess","text":"dataprocess 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import timeclass DataProcess(object): \"\"\"处理自动化输入字符串唯一和结果处理的辅助类\"\"\" def __init__(self): self.time_now = int(time.time()) self.time_now_str = str(self.time_now) def time_stamp(self): return self.time_now def param_time_stamp(self, input_param): \"\"\" 情况一：如果input_param包含iam_，input_param不做处理 情况二：如果input_param包含none，input_param返回空字符串 情况三：除前面两种情况，input_param加时间戳 :param input_param: str :return: str \"\"\" if 'iam_' in input_param: return input_param elif 'none' in input_param: return '' else: return input_param + self.time_now_str def content_handler(self, response): \"\"\" 响应结果为空，返回no_content,响应结果包含&#123;，直接反馈结果，否则响应结果解析成json,然后返回 \"\"\" content = response.text if content == '': return 'no content' elif '&#123;' not in content: return content else: result = response.json() result['status_code'] = response.status_code result['cost_time'] = response.elapsed.microseconds return resultif __name__ == '__main__': data_helper = DataProcess() print(data_helper.time_stamp()) print(data_helper.param_time_stamp('iam_jfwf'))","categories":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/categories/接口测试框架/"}],"tags":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/tags/接口测试框架/"}]},{"title":"RestClient","slug":"RestClient","date":"2019-07-29T15:08:40.000Z","updated":"2019-08-05T13:07:20.976Z","comments":true,"path":"2019/07/29/RestClient/","link":"","permalink":"http://yoursite.com/2019/07/29/RestClient/","excerpt":"封装request方法","text":"封装request方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import requestsfrom common.my_logger import my_loggerfrom common.DataProcess import DataProcessclass RestClient(object): \"\"\"通用request请求封装类\"\"\" def __init__(self): self.logger = my_logger() self.response_helper = DataProcess() def request(self, method, url, headers, params=None, json=None, data=None, log_description=None): \"\"\" http方法的封装 :param method:http请求的方法，str :param url:http请求的url,str :param headers:http请求的header，dict :param params:http请求的查询参数，dict :param json:http请求的body体，json :param data:http请求的body体，dict :param log_description:每个测试类通用的日志打印格式，str :return:http响应的处理结果，json \"\"\" result = &#123;&#125; try: if method == 'post': response = requests.post( url, headers=headers, params=params, json=json, data=data) elif method == 'get': response = requests.get( url, headers=headers, params=params, json=json, data=data) elif method == 'put': response = requests.put( url, headers=headers, params=params, json=json, data=data) elif method == 'delete': response = requests.delete( url, headers=headers, params=params, json=json, data=data) elif method == 'patch': response = requests.patch( url, headers=headers, params=params, json=json, data=data) elif method == 'head': response = requests.head( url, headers=headers, params=params, json=json, data=data) elif method == 'options': response = requests.options( url, headers=headers, params=params, json=json, data=data) except Exception as e: result['error_description'] = e self.logger.error(log_description + 'error: &#123;&#125;'.format(e)) return result self.logger.info(log_description + 'url: &#123;&#125;'.format(response.url)) self.logger.info(log_description + 'params: &#123;&#125;'.format(params)) self.logger.info(log_description + 'headers: &#123;&#125;'.format(headers)) if json: self.logger.info(log_description + 'body: &#123;&#125;'.format(json)) else: self.logger.info(log_description + 'body: &#123;&#125;'.format(data)) self.logger.info(log_description + 'response status_code: &#123;&#125;, ' 'content: &#123;&#125;'.format(response.status_code, response.text)) result = self.response_helper.content_handler(response) return result","categories":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/categories/接口测试框架/"}],"tags":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/tags/接口测试框架/"}]},{"title":"my_logger","slug":"my-logger","date":"2019-07-29T15:05:55.000Z","updated":"2019-08-05T13:05:58.363Z","comments":true,"path":"2019/07/29/my-logger/","link":"","permalink":"http://yoursite.com/2019/07/29/my-logger/","excerpt":"自定义log","text":"自定义log 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from os.path import abspathfrom os.path import dirnameimport logging.handlersdef my_logger(): \"\"\"自定义log，可以根据文件大小或者时间对日志进行分割\"\"\" # logs的路径 base_dir = str(dirname(dirname(abspath(__file__)))) base_dir = base_dir.replace('\\\\', '/') logs_path = base_dir + '/logs/' logger = logging.getLogger('MyLogger') logger.setLevel(logging.DEBUG) message_format = '[%(asctime)s]-[line:%(lineno)d]-[%(levelname)s]-%(message)s' date_format = '%Y-%m-%d %H:%M:%S' bytes_of_100M = 104857600 file_formatter = logging.Formatter(message_format, datefmt=date_format) # 根据大小分割运行日志文件，保留七份，日志级别INFO run_log_path = logs_path + 'trace.log' trace_handler = logging.handlers.RotatingFileHandler( run_log_path, mode=\"a\", maxBytes=bytes_of_100M, backupCount=7, encoding=\"utf-8\") trace_handler.setLevel(logging.INFO) trace_handler.setFormatter(file_formatter) logger.addHandler(trace_handler) # 根据大小分割运行错误日志文件，保留一份，日志级别ERROR error_log_path = logs_path + 'error.log' error_handler = logging.handlers.RotatingFileHandler( error_log_path, mode=\"a\", maxBytes=bytes_of_100M, backupCount=1, encoding=\"utf-8\") error_handler.setLevel(logging.ERROR) error_handler.setFormatter(file_formatter) logger.addHandler(error_handler) # 根据时间分割调试日志文件，保留七天，日志级别DEBUG # debug_log_path = logs_path + 'debug.log' # debug_handler = logging.handlers.TimedRotatingFileHandler( # debug_log_path, when=\"midnight\", interval=1, backupCount=7) # debug_handler.setLevel(logging.DEBUG) # debug_handler.setFormatter(file_formatter) # logger.addHandler(debug_handler) # 使用StreamHandler输出到控制台,日志级别INFO # console_handler = logging.StreamHandler() # console_handler.setLevel(logging.INFO) # console_message_format = '[line:%(lineno)d]-%(levelname)s-%(message)s' # console_formatter = logging.Formatter(console_message_format) # console_handler.setFormatter(console_formatter) # logger.addHandler(console_handler) return loggerif __name__ == '__main__': logger = my_logger() logger.debug('This is a customer debug message') logger.info('This is an customer info message') logger.warning('This is a customer warning message') logger.error('This is an customer error message') logger.critical('This is a customer critical message')","categories":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/categories/接口测试框架/"}],"tags":[{"name":"接口测试框架","slug":"接口测试框架","permalink":"http://yoursite.com/tags/接口测试框架/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-28T06:56:15.051Z","updated":"2019-08-03T03:51:50.539Z","comments":true,"path":"2019/07/28/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/28/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}